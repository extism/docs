---
slug: wasm-actors-using-elixir
title: "Wasm actors using Elixir"
authors: [ben]
tags: [WebAssembly, Elixir]
---

### Wasm Actors in Elixir

When I first started working with Wasm, I felt there was a natural synergy between Wasm and the actor model.
The most powerful example of the actor model is, in my opinion, the [BEAM and OTP](https://www.erlang.org/).
So naturally, I built [Elixir support](/docs/integrate-into-your-codebase/elixir-or-erlang-host-sdk) into Extism by creating an Elixir Host SDK.

I wanted to explore this idea of a Wasm module as an Erlang process and see what kind of interesting things could you create
when you combined this with OTP. Along the way I discovered that an Extism plugin maps almost perfectly with the interface of
the [GenServer](https://hexdocs.pm/elixir/GenServer.html) behavior. This has some powerful implications! This means you can map

In this post I'm going to explain how to set this up and we'll try running a few experiments.

### Setting up Extism

We generally recommend people install the [Extism CLI](https://extism.org/docs/install/) to get started. This installs
the extism runtime on your machine and gives you some commands to play with. With the Elixir library, it's not needed.
You just need rust installed as we ship the runtime source along with the Elixir package.

#### Install Depdendencies

All you need to get started is [rustup](https://rustup.rs/) and [elixir](https://elixir-lang.org/install.html).
If you have these installed you can skip to the next section.

> **N.B.**: I'm doing all this on an Ubuntu jammy docker container. You can grab a shell session with `docker run -it ubuntu:latest bash`.

```bash
apt update
apt install -y curl build-essential
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
# Choose 1 for default
source "$HOME/.cargo/env"
apt install -y elixir
```

#### Create an Elixir project

Now let's create a new Elixir project with `mix`:

```bash
mix new wasmactor
cd wasmactor
```

Now let's add Extism as a dependency in `mix.exs`

```elixir
  defp deps do
    [
        # ...
        {:extism, "~> 0.1.0"},
    ]
  end
```

Now fetch the deps and compile them:

```bash
mix do deps.get, deps.compile
```

This should kick off a rust build of the Extism package and runtime and it should end something like this:

```bash
Finished release [optimized] target(s) in 3m 39s
Generated extism app
```

:::info Getting Support

If you do run into a problem at any point please [file an issue](https://github.com/extism/extism/issues) or reach out
on [Discord](https://discord.gg/cx3usBCWnc).

:::

#### Running a plugin

Let's test this out in a repl. Before we do that, let's pull down an already compiled wasm plugin to execute:
This is our "count-vowels" example plugin:

```bash
curl https://raw.githubusercontent.com/extism/extism/main/wasm/code.wasm > code.wasm
```

Now open an IEx repl:

```bash
iex -S mix
```

Paste in this code. This creates an Extism Context and loads the Plugin. Then it calls the `count_vowels`
function on the plugin with a test string and returns the output of the plugin (which in this case is a JSON encoded result).

```elixir
ctx = Extism.Context.new
manifest = %{ wasm: [ %{ path: "./code.wasm" } ]}
{:ok, plugin} = Extism.Context.new_plugin(ctx, manifest, false)
{:ok, output} = Extism.Plugin.call(plugin, "count_vowels", "this is a test")
JSON.decode!(output)
```

If all is working you'll see 4 vowels in the input string:

```
iex(5)> JSON.decode!(output)
%{"count" => 4}
```

#### Utilizing OTP

Okay, how do we turn this into a [GenServer](https://hexdocs.pm/elixir/GenServer.html)?
There would be two approaches:

1. Wrap the Extism Context in the Genserver
    * Store the Context as the state
    * Provide callbacks to load and unload plugins
    * Provide callbacks to lookup and call those plugins
2. Wrap the Extism Plugin in the Genserver
    * Store both the context and the plugin as state
    * Provide callbacks to load and reload the plugin code
    * Provide callbacks to call functions on the plugin

:::info What is a Context?

You can think of a Context right now as an arena of plugins. When a plugin is loaded, the context owns
that plugin and is responsible for freeing it. Freeing a context frees all it's plugins.

:::

I went with #2 here because I think it's more granular and allows for more flexibility and concurrency.
There isn't much of a penalty to have one context per plugin so it's okay to do it this way.

With that in mind, I implemented this GenServer in `lib/wasmactor.ex`:

```elixir
defmodule Wasmactor.PluginServer do
  use GenServer

  @impl true
  def init(_init_arg) do
    ctx = Extism.Context.new()
    # as our state we will store a {Context, Plugin} tuple
    {:ok, {ctx, nil}}
  end

  # This special call is for loading or reloading a plugin given a manifest
  @impl true
  def handle_call({:new, manifest, wasi}, _from, {ctx, plugin}) do
    # if we have an exiting Plugin let's free it
    if plugin do
        Extism.Plugin.free(plugin)
    end
    # Load a new plugin given the manifest and store it in the new state
    {:ok, plugin}  = Extism.Context.new_plugin(ctx, manifest, wasi)
    {:reply, {:ok, plugin}, {ctx, plugin}}
  end

  # this is a generic way to call functions on the Extism.Plugin module
  # we're mostly going to use `call` here:
  #     e.g. call_details = {:call, "count_vowels", "this is a test"}
  @impl true
  def handle_call(call_details, _from, {ctx, plugin}) do
    [func_name | args] = Tuple.to_list(call_details)
    response = apply(Extism.Plugin, func_name, [plugin | args])
    {:reply, response, {ctx, plugin}}
  end
end
```

Okay let's try the count vowels example again but now with a GenServer:

```elixir
iex(1)> {:ok, pid} = GenServer.start_link(Wasmactor.PluginServer, nil)
{:ok, #PID<0.220.0>}
iex(2)> GenServer.call(pid, {:new, %{wasm: [%{path: "./code.wasm"}]}, false})
{:ok,
 %Extism.Plugin{
   ctx: %Extism.Context{ptr: #Reference<0.584822572.876216322.21881>},
   plugin_id: 0
 }}
iex(3)> GenServer.call(pid, {:call, "count_vowels", "this is a test"})
{:ok, "{\"count\": 4}"}
```

Now we're doing the same thing, but instead of invoking a function on the plugin we're 
invoking it on a pid. What does this inversion give us exactly? Well, because it's a pid, it can live anywhere
in your cluster.

This also means we can replace any GenServer in our application, or in a framework like Phoenix, with a Wasm module.
This would allow your customers to extend your application or maybe allow you to write part of your Elixir application
in a language better suited to the task of the GenServer you are replacing.

We're currently working on something to demonstrate this idea. We will follow up in the coming weeks with a new blog post.
